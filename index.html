<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>分流器电池效率计算器</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body {
    font-family: "Segoe UI", "Microsoft YaHei", system-ui, sans-serif;
    background: #0f172a;
    color: #e5e7eb;
    margin: 0;
    padding: 20px;
  }
  .container {
    max-width: 900px;
    margin: auto;
    background: #020617;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,.4);
  }
  h1 { margin-top: 0; font-size: 22px; }
  .subtitle { margin: 6px 0 16px 0; font-size: 13px; color: #94a3b8; }
  .grid {
    display: grid;
    grid-template-columns: minmax(120px, 200px) 1fr;
    gap: 12px;
    margin-bottom: 16px;
  }
  label { align-self: center; }
  input, select, button, textarea { font-family: inherit; font-size: 14px; }
  input, select, textarea {
    background: #020617; color: #e5e7eb; border: 1px solid #1e293b; border-radius: 6px; padding: 8px;
  }
  button {
    background: #2563eb; border: none; border-radius: 8px; padding: 10px 16px; color: white; cursor: pointer; font-weight: 600;
  }
  button:hover { background: #1d4ed8; }
  textarea { width: 100%; height: 260px; resize: vertical; margin-top: 12px; white-space: pre-wrap; }
  .footer { opacity: 0.6; margin-top: 10px; font-size: 12px; }

  @media (max-width: 600px) {
    body { padding: 12px; }
    .container { padding: 14px; border-radius: 10px; }
    h1 { font-size: 18px; }
    .grid { grid-template-columns: 1fr; gap: 8px; }
    input, select, button, textarea { font-size: 16px; }
    button { width: 100%; }
    textarea { height: 200px; }
  }
</style>
</head>
<body>
  <div class="container">
    <h1>分流器电池效率计算器</h1>
    <p class="subtitle">本计算器采用的分流器全部为1分2的分流，不采用1分3的情况</p>

    <div class="grid">
      <label>分流器数量 N：</label>
      <input id="nInput" type="number" value="12" min="1" max="256" />

      <label>电池类型：</label>
      <select id="batterySelect">
        <option value="0">谷地 (1100)</option>
        <option value="1">武陵 (1600)</option>
      </select>

      <label>期望耗电量：</label>
      <input id="expectedInput" type="number" value="5000" step="5" />
    </div>

    <button onclick="onCalculate()">计算</button>

    <textarea id="output" readonly></textarea>

    <div style="margin-top:12px;">
      <button id="genImgBtn" onclick="onGenerateImage()" style="display:none;">生成结构图</button>
    </div>

    <div id="imageContainer" style="margin-top:12px; display:none;">
      <img id="resultImage" style="max-width:100%; height:auto; display:block; border-radius:8px;"/>
      <button id="openOriginalBtn" style="margin-top:8px; display:none;" onclick="openOriginalImage()">在新页面查看原图</button>
    </div>

    <div class="footer">本工具为本地 HTML 页面，不联网，不上传数据。</div>
  </div>

<script>
/* ---------- Fraction (BigInt) ---------- */
class Fraction {
  constructor(n, d = 1n) {
    if (d === 0n) throw new Error("分母不能为0");
    if (d < 0n) { n = -n; d = -d; }
    const g = Fraction.gcd(n < 0n ? -n : n, d);
    this.n = n / g; this.d = d / g;
  }
  static gcd(a, b) { while (b !== 0n) { const t = a % b; a = b; b = t; } return a; }
  add(o) { return new Fraction(this.n * o.d + o.n * this.d, this.d * o.d); }
  sub(o) { return new Fraction(this.n * o.d - o.n * this.d, this.d * o.d); }
  mul(o) { return new Fraction(this.n * o.n, this.d * o.d); }
  div(o) { return new Fraction(this.n * o.d, this.d * o.n); }
  gt(o) { return this.n * o.d > o.n * this.d; }
  toFloat() { return Number(this.n) / Number(this.d); }
  toString() { if (this.d === 1n) return this.n.toString(); return this.n.toString() + "/" + this.d.toString(); }
}

/* ---------- 原算法（返回 dp_actual） ---------- */
function mult_of_two_or_three(x) {
  if (x <= 0n) return false;
  let c2 = 0, c3 = 0;
  while (x % 2n === 0n) { c2++; x /= 2n; }
  while (x % 3n === 0n) { c3++; x /= 3n; }
  if (x === 1n) return [c2, c3];
  return false;
}

function calculateWithDp(N, battery_type, expected_electricity) {
  let output = [];

  if (!Number.isInteger(N) || N <= 0) throw new Error("分流器数量必须为正整数");
  if (N > 256) throw new Error("分流器数量不能超过256");
  if (![0,1].includes(battery_type)) throw new Error("电池类型必须为0或1");
  if (expected_electricity <= 0) throw new Error("期望耗电量必须为正数");
  if (expected_electricity % 5 !== 0) throw new Error("期望耗电量必须为5的倍数");

  const Belt_efficiency = new Fraction(1n, 2n);
  const Battery_lasting_seconds = 40n;
  const Central = 200n;

  const efficiency = 1100n + BigInt(battery_type) * 500n;
  const energy_generated = efficiency * Battery_lasting_seconds;

  const full_load = (BigInt(expected_electricity) - Central) / efficiency;
  const target = (BigInt(expected_electricity) - Central) % efficiency;
  const serving_efficiency = new Fraction(target, energy_generated);

  const den = serving_efficiency.d;
  const mults = mult_of_two_or_three(den);
  if (serving_efficiency.n !== 0n && mults) {
    output.push("当前版本的电池效率为1100和1600，无法完美电量，因此这个方法留在以后再实现\n");
    return { text: output.join(""), dp_actual: null };
  }

  let dp = new Array(N).fill(0);

  let max_scaling = new Fraction(1n << BigInt(N), 1n);
  let target_efficiency = serving_efficiency.mul(max_scaling);
  let current = Belt_efficiency.mul(max_scaling);

  for (let i = 0; i < N - 1; i++) {
    current = current.div(new Fraction(2n,1n));
    if (current.gt(target_efficiency)) continue;
    dp[i] = 1;
    target_efficiency = target_efficiency.sub(current);
  }

  let is_last_necessary = 0;
  if (current.gt(target_efficiency)) {
    if (current.div(new Fraction(2n,1n)).gt(target_efficiency)) {
      dp[N-1] = 1;
    } else {
      dp[N-1] = 2;
    }
  } else {
    dp[N-2] += 1;
  }

  let check = 2;
  let i = N - 1;
  while (check > 0 && i > 0) {
    if (dp[i] > 1) {
      dp[i-1] += 1;
      dp[i] -= 2;
      is_last_necessary = N - i;
    } else if (dp[i] === 0 && check === 2) {
      is_last_necessary = 1;
    } else {
      check -= 1;
    }
    i--;
  }

  const dp_actual = dp.slice(0, N - is_last_necessary);

  let actual_efficiency = new Fraction(0n,1n);
  for (let i = 0; i < dp_actual.length; i++) {
    if (dp_actual[i] > 0) {
      const term = new Fraction(BigInt(dp_actual[i]),1n)
        .mul(new Fraction(1n, 1n << BigInt(i + 1)))
        .mul(Belt_efficiency);
      actual_efficiency = actual_efficiency.add(term);
    }
  }

  output.push(`需要 ${full_load} 个全速发电器\n`);
  output.push(`实际使用了 ${N - is_last_necessary} 个分流器\n`);

  let temp_list = [];
  for (let i = 0; i < dp_actual.length; i++) if (dp_actual[i] > 0) temp_list.push(`第${i+1}`);
  if (temp_list.length > 0) output.push(`需连接 ${temp_list.join(", ")} 个分流器至输出口\n`);
  else output.push("不需要连接任何分流器至输出口\n");

  const interval = new Fraction(1n,1n).div(actual_efficiency);
  output.push(`每 ${interval.toFloat().toFixed(6)} 秒运送一个电池至发电器 (${interval.toString()})\n`);

  const actual_total = new Fraction(energy_generated,1n).mul(actual_efficiency)
    .add(new Fraction(full_load * efficiency + Central,1n));

  const batteries_per_min = new Fraction(full_load, 1n)
    .add(actual_efficiency.mul(new Fraction(60n, 1n)));

  output.push(`每分钟消耗电池约 ${batteries_per_min.toFloat().toFixed(6)} 个 (${batteries_per_min.toString()})\n`);
  output.push(`目标效率为 ${expected_electricity}\n`);
  output.push(`实际效率为 ${actual_total.toFloat().toFixed(6)} (${actual_total.toString()})\n`);

  return { text: output.join(""), dp_actual };
}

/* ---------- 图片加载与绘制（严格复刻 Python 旋转逻辑） ---------- */
let lastDpActual = null;
let lastImageDataURL = null;

const images = {};
const imageList = {
  belt: "src/img/belt.png",
  belt_turn: "src/img/belt_turn.png",
  combiner: "src/img/combiner.png",
  diverter: "src/img/diverter.png",
  logistics_bridge: "src/img/logistics_bridge.png",
  generator: "src/img/generator.png"
};

function loadAllImages() {
  const entries = Object.entries(imageList);
  let loaded = 0;
  return new Promise((resolve, reject) => {
    entries.forEach(([key, src]) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        images[key] = img;
        loaded++;
        if (loaded === entries.length) resolve();
      };
      img.onerror = () => reject(new Error("加载图片失败: " + src));
    });
  });
}

function drawRotated(ctx, img, x, y, tile, angleDeg) {
  const rad = angleDeg * Math.PI / 180;
  ctx.save();
  ctx.translate(x*tile + tile/2, y*tile + tile/2);
  ctx.rotate(rad);
  ctx.drawImage(img, -tile/2, -tile/2, tile, tile);
  ctx.restore();
}

async function onGenerateImage() {
  if (!lastDpActual) return;

  await loadAllImages();

  const tile = 224;
  const n = lastDpActual.length;

  // Python: total_cols = n + 2; big_w = (total_cols + 1) * w + generator.width
  const total_cols = n + 2;
  const canvas = document.createElement("canvas");
  canvas.width = (total_cols + 1) * tile + images.generator.width;
  canvas.height = 4 * tile;
  const ctx = canvas.getContext("2d");

  // 旋转版本（对应 Python）
  // img1 = belt
  // img1_r90 = img1.rotate(-90)
  // img1_r180 = img1.rotate(180)
  // img2 = combiner
  // img2_r180 = img2.rotate(180)

  // 最左边新增一列：1, blank, blank, 1(r180)
  // 用 belt 与 belt 180°
  ctx.drawImage(images.belt, 0*tile, 0*tile, tile, tile);
  drawRotated(ctx, images.belt, 0, 3, tile, 180);

  let seen_first_one = false;

  for (let i = 0; i < n; i++) {
    const x = i + 1;
    const v = lastDpActual[i];

    if (i === n - 1) {
      // 最后一列：强制按 0 的样式（“已遇到1之后”的版本）
      // [img3, img4, img1_r90, img2_r180]
      // img3 = diverter, img4 = logistics_bridge, img1_r90 = belt(-90), img2_r180 = combiner(180)
      ctx.drawImage(images.diverter, x*tile, 0*tile, tile, tile);
      ctx.drawImage(images.logistics_bridge, x*tile, 1*tile, tile, tile);
      drawRotated(ctx, images.belt, x, 2, tile, 90);
      drawRotated(ctx, images.combiner, x, 3, tile, 180);
    } else {
      if (v === 1) {
        seen_first_one = true;
        // [img3, img2, blank, img2_r180]
        // img3 = diverter, img2 = combiner, img2_r180 = combiner(180)
        ctx.drawImage(images.diverter, x*tile, 0*tile, tile, tile);
        ctx.drawImage(images.combiner, x*tile, 1*tile, tile, tile);
        drawRotated(ctx, images.combiner, x, 3, tile, 180);
      } else {
        // v == 0
        ctx.drawImage(images.diverter, x*tile, 0*tile, tile, tile);
        if (!seen_first_one) {
          // 第一个 1 之前的 0: [img3, img1_r90, img1_r90, img2_r180]
          drawRotated(ctx, images.belt, x, 1, tile, 90);
          drawRotated(ctx, images.belt, x, 2, tile, 90);
          drawRotated(ctx, images.combiner, x, 3, tile, 180);
        } else {
          // 第一个 1 之后的 0: [img3, img4, img1_r90, img2_r180]
          ctx.drawImage(images.logistics_bridge, x*tile, 1*tile, tile, tile);
          drawRotated(ctx, images.belt, x, 2, tile, 90);
          drawRotated(ctx, images.combiner, x, 3, tile, 180);
        }
      }
    }
  }

  // 追加的第 1 列：2, 5, blank, blank
  // Python: [img2, img5, blank, blank] => combiner, belt_turn
  const x1 = n + 1;
  ctx.drawImage(images.combiner, x1*tile, 0*tile, tile, tile);
  ctx.drawImage(images.belt_turn, x1*tile, 1*tile, tile, tile);

  // 追加的第 2 列：1, blank, blank, blank => belt
  const x2 = n + 2;
  ctx.drawImage(images.belt, x2*tile, 0*tile, tile, tile);

  // 追加的第 3 列：generator
  const x3 = n + 3;
  ctx.drawImage(images.generator, x3*tile, 0);

  const dataURL = canvas.toDataURL("image/png");
  lastImageDataURL = dataURL;

  const imgEl = document.getElementById("resultImage");
  imgEl.src = dataURL;
  document.getElementById("imageContainer").style.display = "block";
  document.getElementById("openOriginalBtn").style.display = "inline-block";
}

/* ---------- UI ---------- */
function openOriginalImage() {
  if (!lastImageDataURL) return;
  const w = window.open();
  w.document.write(`<img src="${lastImageDataURL}" style="display:block;">`);
}

function onCalculate() {
  const out = document.getElementById("output");
  document.getElementById("imageContainer").style.display = "none";
  document.getElementById("genImgBtn").style.display = "none";
  document.getElementById("openOriginalBtn").style.display = "none";
  lastDpActual = null; lastImageDataURL = null;

  try {
    const N = parseInt(document.getElementById("nInput").value, 10);
    const battery_type = parseInt(document.getElementById("batterySelect").value, 10);
    const expected = parseInt(document.getElementById("expectedInput").value, 10);

    const result = calculateWithDp(N, battery_type, expected);
    out.value = result.text;
    lastDpActual = result.dp_actual;

    if (lastDpActual) document.getElementById("genImgBtn").style.display = "inline-block";
  } catch (e) {
    out.value = "错误: " + e.message;
  }
}
</script>
</body>
</html>
